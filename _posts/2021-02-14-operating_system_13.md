---
title: "운영체제 요약 - 13. 입출력 시스템"
last_modified_at: 2021-04-07
show_date: true
classes: wide
excerpt: ""
categories:
  - operating_system
---

## 13.1. 개관(Overview)
입출력 장치들은 기능이나 속도 면에서 매우 다양한 특성을 보이기 때문에 각각의 특성에 맞는 제어가 필요하다. 
이와 같은 다양한 제어 방법들이 커널의 입출력 서브시스템을 형성하며, 이들은 커널의 다른 부분이 입출력 장치를 관리하는 일에 신경을 쓰지 않게 해준다. 

서로 다른 장치들의 다양성을 해결하기 위해, 커널은 장치 드라이버 모듈(device driver module)을 사용한다. 
장치 드라이버는 모든 하드웨어를 일관된 인터페이스로 표현해 주며, 이 인터페이스를 상위 층인 커널의 입출력 서브시스템에게 제공해 준다. 

## 13.2. 입출력 하드웨어(I/O Hardware)
하드웨어 장치는 케이블을 통하거나 무선으로 신호를 보냄으로써 컴퓨터 시스템과 통신한다. 
이들 장치는 포트(port)라 불리는 연결점을 통해 컴퓨터와 접속된다. 

만약 하나 이상의 장치들이 공동으로 여러 선들 사용한다면, 이러한 선을 버스(bus)라고 부른다. 
즉, 버스의 정의는 회선의 집합으로써 이를 통해 어떻게 메세지들을 주고 받을지를 정한 프로토콜(protocol)까지 포함한다. 

<figure style="width: 600px" class="align-center">
 	<img src="{{ '/assets/img/2021-02-14-operating_system_13/1.png' }}" alt=""> 
</figure> 

제어기(controller)는 포트, 버스, 입출력 장치를 제어하는 전자 회로의 집합이다. 
직렬 포트 제어기처럼 간단할 경우 하나의 칩, SCSI 버스 제어기 처럼 복잡한 경우 회로 보드(프로세서, 마이크로 코드, 메모리가 있을 수 있음) 등이 있다. 
입출력 장치에 내장되어있는 제어기도 있다. 
예를 들어, 디스크 제어기는 프로토콜의 디스크 측 부분을 수행하고 섹터 매핑, 캐싱 같은 작업을 하는 마이크로코드와 프로세서를 가진다. 

모든 제어기는 레지스터를 가지고 있으며, 컴퓨터의 프로세서는 이 레지스터에 비트 패턴을 쓰거나 읽음으로써 입출력을 수행한다. 
이러한 통신을 수행하는 한 방법은 입출력 명령어를 사용하는 것이다. 

명령어를 통해 해당 장치에 맞는 버스 회선을 선택하고 장치 레지스터로 비트들을 보내거나 읽어온다. 
다른 방법은 메모리 맵 입출력(memory-mapped I/O)라 불리는, 장치 레지스터를 프로세스의 주소 공간으로 사상하는 방법이다. 

CPU는 물리 메모리에 사상된 장치 레지스터를 읽고 쓸 때 표준 데이터 전송 명령을 사용함으로써 입출력 요청을 수행한다. 
어떤 시스템은 두 가지를 다 제공한다. 

입출력 포트는 보통 네 개의 레지스터로 구성되어 있다. 
* 입력 레지스터를 호스트가 읽는다. 
* 출력 레지스터에 호스트가 출력을 쓴다.
* 상태 레지스터는 명령이 완료되었는지, 입력 레지스터를 읽어도 되는지, 오류가 있었는지를 나타낸다. 
* 제어 레지스터를 통해 호스트가 입출력 명령을 내리거나 장치의 모드를 변경한다. 
예를 들어, 쌍/단방향 통신 설정, 패리티 검사 여부 설정 등이 있다. 

어떤 제어기들은 이러한 레지스터들을 위해 FIFO칩들을 가지고 있다. 
FIFO칩은 장치나 호스트가 데이터를 받기 전까지 데이터를 가지고 있을 수 있다. 

### 13.2.1. 폴링(Polling)
장치 제어기가 작업을 하느라고 바쁠 경우 상태 레지스터의 비지(busy) 비트는 1로 설정되어있다. 
그동안 호스트는 추가적인 명령을 줄 수 없다. 

폴링에서 호스트는 바쁜 대기(busy-waiting)을 한다. 
즉, 장치의 작업이 끝나 상태 레지스터의 비지 비트가 0이 될 때 까지, 상태 레지스터를 계속 검사한다. 

이럴 경우 CPU는 시간을 낭비하게 되고, 
해결을 위해 입출력 장치가 CPU에게 자신의 상태 변화를 통보하는 하드웨어 기법 인터럽트가 필요하다. 

### 13.2.2. 인터럽트(Interrupts)
기본 인터럽트 기법은 다음과 같다. 
CPU 하드웨어는 인터럽트 요청 라인이라고 불리는 선을 가지며, CPU는 매 명령어를 끝내고 다음 명령어를 수행하기 전에 이 선을 검사한다. 

입출력 하드웨어 제어기가 이 요청 라인에 신호를 보내면, CPU는 현재 상태를 저장하고, 메모리의 인터럽트 핸들러 루틴으로 이동한다. 
인터럽트 핸들러는 인터럽트의 원인을 조사하고 필요한 작업을 수행한 후, CPU를 이전 상태로 되돌린다. 

<figure style="width: 650px" class="align-center">
 	<img src="{{ '/assets/img/2021-02-14-operating_system_13/2.png' }}" alt=""> 
</figure> 

현재 운영체제는 더욱 세분화된 인터럽트 핸들링 방법을 제공한다. 
인터럽트를 연기시키거나, 어떤 장치가 인터럽트를 발생시켰는지 알거나, 인터럽트에 우선순위를 줄 수도 있다. 

이들을 위해 두 종류의 인터럽트 요청 라인을 가진다. 
하나는 회복 불가능한 메모리 오류와 같은 이벤트를 위해 사용되는 마스크 불가 인터럽트(nonmaskable interrupt)이고, 
다른 하나는 필요 시 인터럽트 기능을 잠시 중단시켜 놓을 수 있는 마스크 가능 인터럽트(maskable interrupt)이다. 

인터럽트 기법은 보통 주소라고 하는, 하나의 정수를 받는데, 이 정수는 특정 인터럽트 핸들링 루틴을 선택하기 위해 사용된다. 
대부분의 아키텍처에서 이 주소는 인터럽트 벡터라고 불리는 테이블의 오프셋으로 사용된다. 
이 벡터에는 인터럽트 핸들러들의 메모리 주소가 있다. 

그러나 컴퓨터가 인터럽트 벡터 내에 있는 주소들보다 더 많은 장치를 가질 수 있다. 
이럴 경우 인터럽트 사슬화(chaning)을 사용하는데, 벡터의 각 항목에 여러 인터럽트 핸들러로 이루어진 리스트를 저장한다. 
인터럽트가 발생하면, 해당 핸들러를 찾을 때까지 리스트를 하나씩 검사한다. 

또한 인터럽트 기법은 인터럽트 우선순위 수준의 구현을 가능하게 한다. 
자동적으로 높은 우선순위 인터럽트가 낮은 우선순위의 인터럽트를 선점(preempt)할 수 있게 한다. 

즉, 인터럽트는 비동기적(asynchronous)으로 일어나는 사건을 처리하고, 커널내의 수퍼바이저 루틴(supervisor routine)으로 이동하기 위해 사용된다. 
입출력 장치, 하드웨어 고장, 시스템 호출과 같은 사건들이 모두 인터럽트를 야기하고 커널 루틴을 촉발한다. 

### 13.2.3. 직접 메모리 접근(DMA, Direct Memory Access)
CPU가 상태 비트를 검사하면서 데이터를 옮기는 입출력 방식을 PIO(Programmed I/O)라고 한다. 
많은 컴퓨터들은 CPU의 PIO 작업 중 일부를 DMA 제어기라 불리는 특수 프로세서에게 위임함으로써 CPU의 일을 줄인다. 

DMA 제어기와 장치 제어기간의 핸드셰이킹은 DMA-request와 DMA-acknowledge라 불리는 두 개의 선을 통해 수행된다. 
장치 제어기는 전송할 자료가 생기면 DMA-request에 신호를 보낸다. 

request 신호를 받으면 DMA 제어기가 메모리 버스를 얻고, 메모리-주소 선들에 원하는 주소를 올린다. 
그 후 DMA-acknowledge 선에 신호를 보낸다. 

장치 제어기가 acknowledge 신호를 받으면 데이터를 메모리로 전송하고 DMA-requeset 신호를 제거한다. 
전송이 완전히 끝나면 DMA 제어기는 CPU에게 인터럽트를 건다. 

<figure style="width: 620px" class="align-center">
 	<img src="{{ '/assets/img/2021-02-14-operating_system_13/3.png' }}" alt=""> 
</figure> 

DMA 제어기가 메모리 버스를 점유 중이면 CPU는 메모리에 접근하지 못하지 못한다. 
이러한 사이클 스틸링(cycle stealing)은 CPU의 속도를 저하시키지만 입출력 작업을 DMA로 넘김으로써 전제척인 시스템 성능은 향상된다. 

DMA는 물리 주소로 사상된 가상 주소에도 사용될 수 있다. 
이를 직접 가상 주소 접근(DMVA, direct virtual memory access)라고 한다. 
DMVA는 CPU나 메모리의 개입 없이 memory-mapped 장치들 간의 데이터 전송을 할 수 있게 한다. 

### 13.2.4. 입출력 하드웨어 요약
* 버스, 제어기, 입출력 포트와 레지스터
* 호스트와 장치 제어기간의 핸드셰이킹
* DMA 제어기

## 13.3. 응용 입출력 인터페이스(Application I/O Interface)
모든 입출력 장치들이 일관된 방법으로 다루어질 수 있도록 운영체제는 인터페이스를 구성한다. 
장치들을 몇 가지 대표적인 종류로 정의하고, 인터페이스라고 불리는 표준 함수들의 집합을 통하여 접근한다. 
장치 드라이버(device driver)라고 부르는 커널 내의 모듈들은 각 입출력 장치를 위한 코드를 제공하며, 인터페이스의 표준 함수들을 사용한다. 

<figure style="width: 610px" class="align-center">
 	<img src="{{ '/assets/img/2021-02-14-operating_system_13/4.png' }}" alt=""> 
</figure> 

입출력 장치들은 여러 가지 차원에서 다양하다.  
* 문자 스트림 장치는 바이트를 하나씩 전송하지만, 블록 장치는 블록 단위로 전송한다. 
* 순차 장치는 순차적 순서로만 자료를 전송하지만, 임의 접근 장치는 임의의 위치에 있는 자료도 입출력할 수 있다.
* 동기식 장치는 시스템과 조율하여 일정한 응답 시간을 보이지만, 비동기식 장치는 다른 사건과 조율 없이 불규칙한 응답 시간을 보인다. 
* 공유 가능한 장치는 몇 개의 프로세스나 스레드에 의해 동시에 사용 될 수 있으나, 전용 장치는 그럴 수 없다. 
* 장치 속도는 초당 몇 바이트에서 기가바이트까지 다양하다.
* 읽기/쓰기, 읽기 전용, 쓰기 전용인 장치들이 있다. 

### 13.3.1. 블록 장치와 문자 장치(Block and Character Device)
응용 프로그램은 보통 파일 시스템 인터페이스를 통해, 이 블록 장치 인터페이스에 접근한다. 
read, write, seek 등의 명령이 제공된다. 

데이터베이스와 같이 어떤 응용은 자체적으로 버퍼링을 수행한다. 
따라서 파일 시스템의 버퍼링은 불필요한 중복 버퍼링이 된다. 

이를 해결하기 위해 운영체제는 블록 장치를 마치 선형 배열처럼 제공하는 raw 입출력을 제공하기도 한다. 
다른 대안은 운영체제가 버퍼링과 잠금을 하지 않는 모드로 파일에 대한 입출력 작업을 하는 것이다. 
UNIX에서는 이를 직접 입출력(direct I/O)라 한다. 

키보드 처럼 문자 스트림 인터페이스를 통해 접근되는 장치도 있다. 
이 인터페이스의 시스템 호출은 응용 프로그램에게 한 글자를 보내거나 받아오는 명령을 제공한다. 
한 줄 읽기, 버퍼링과 편집 기능도 있다. 

### 13.3.2. 네트워크 장치(Network Devices)
네트워크 소켓(socket) 인터페이스는 네트워크 입출력을 제공한다. 
소켓 인터페이스에서 시스템 호출은 응용 프로그램이 소켓을 생성하고, 이를 원격지 주소(다른 응용이 생성한 소켓)와 연결하고, 접속이 되었는지 알아보고, 패킷(packet)을 주고받도록 해준다. 

서버는 select() 시스템 호출을 쓸 수 있는데, 이는 어느 소켓이 수신 대기 중인 패킷을 가지고 있는지를 폴링없이 알게 해준다. 

### 13.3.3. 클록과 타이머(Clocks and Timers)
대부분의 컴퓨터들은 하드웨어 클록과 타이머를 가지고 3가지 기본 기능을 제공한다. 
* 현재 시간 제공
* 이전 사건에서 경과된 시간 제공
* T 시각이 되면 X 작업 실행

경과한 시간을 재고, 작업을 실행시키는 하드웨어를 programmable interval timer라고 한다. 
이는 어느 시간만큼 경과되면 인터럽트를 발생시키거나, 한번 또는 주기적으로 발생하도록 설정할 수 있다. 

운영체제가 virtual clock을 흉내냄(simulate)으로써 타이머 하드웨어보다 더 많은 타이머 관련 요청을 지원할 수도 있다. 

### 13.3.4. 봉쇄형과 비봉쇄형 입출력(Blocking and Nonblocking I/O)
봉쇄형 입출력에서 프로세스는, 입출력 요청이 생길 경우 wait queue에서 대기한다. 
그리고 요청이 완료되면 ready queue로 이동한다. 

비봉쇄형 입출력에서는 요청된 입출력이 완료되거나 되지 않았어도 프로세스로 즉각 복귀한다. 
데이터가 준비되지 않은 경우에도, 프로세스가 대기하지 않는다. 

비봉쇄형 입출력의 대안으로 비동기식(asynchronous) 입출력이 있다. 
비봉쇄형과 마찬가지로 입출력을 요청한 후 프로세스로 복귀한다. 
입출력이 완료되면, 운영체제가 프로세스에게 데이터가 사용가능하다고 알린다. 

<figure style="width: 680px" class="align-center">
 	<img src="{{ '/assets/img/2021-02-14-operating_system_13/5.png' }}" alt=""> 
</figure> 

### 13.3.5. 벡터형 입출력(Vectored I/O)
벡터형 입출력은 하나의 시스템 호출을 호출하여 복수의 위치에 여러 입출력 연산을 수행할 수 있게 한다. 
동일한 전송은 시스템 호출을 여러 번 호출하여 수행할 수 있지만, 이러한 scatter-gather 방식이 유용하다. 

여러 개의 개별 버퍼의 내용을 한번의 시스템 호출을 통하여 입출력 할 수 있어 문맥 교환과 시스템 호출 오버헤드를 줄일 수 있다. 
게다가 일부 버전의 scatter-gather 입출력은 원자성을 제공하여 모든 입출력은 방해받지 않는 것을 보장한다. 

## 13.4. 커널 입출력 서브시스템(Kernel I/O Subsystem)

### 13.4.1. 입출력 스케줄링
운영체제는 각각의 장치마다 wait queue를 유지함으로써 스케줄링을 구현하고 있다. 
응용 프로그램이 봉쇄형 입출력 시스템 호출을 하면, 그 입출력 요청은 해당 장치의 queue에 넣어진다. 
입출력 스케줄러는 평균 응답 시간을 향상시키기 위해 queue안의 순서를 재배치한다. 

운영체제는 비동기 입출력을 제공하기 위해, 장치 상태 테이블(device-status table)에 wait queue를 연동하다. 
테이블의 각 항목은 장치의 종류, 주소, 상태를 표시한다. 

<figure style="width: 650px" class="align-center">
 	<img src="{{ '/assets/img/2021-02-14-operating_system_13/6.png' }}" alt=""> 
</figure> 

### 13.4.2. 버퍼링(Buffering)
버퍼는 두 장치 사이 또는 장치와 응용 프로그램 사이에 데이터가 전송되는 동안 전송 데이터를 임시로 저장하는 메모리 영역을 말한다. 
버퍼는 세 가지 이유 때문에 사용된다. 

첫 번째 이유는 데이터의 생산자와 소비자 사이에 속도가 다른 것에 대처하기 위함이다. 
예를 들어, 모뎀은 디스크보다 매우 느리다. 

따라서 모뎀으로부터 수신되는 바이트를 임시로 메모리 버퍼에 저장한다. 
버퍼가 가득차면, 디스크에 기록을 시작하며, 또 다른 버퍼가 모뎀으로부터 채워진다. 
이렇게 두 개의 버퍼가 상호 교대로 사용되는 이중 버퍼링(double buffering)은 속도 차이를 흡수할 수 있다. 

두 번째 경우는 데이터 전송 크기가 다른 장치들 사이의 완충을 제공할 때이다. 
특히 네트워킹에서 송신측의 큰 메세지는 작은 네트워크 패킷으로 나누어진다. 
전송된 패킷은 수신측에서 원래의 자료로 복원하기 위해 버퍼에서 결합한다. 

세 번째 경우는 copy semantics를 지원하기 위함이다. 
예를 들어, 응용 프로그램이 디스크 쓰기 요청을 할 때, 데이터는 사용자의 메모리 영역에서 커널 버퍼로 먼저 복사되고 디스크에 기록된다. 
이 후 응용 프로그램이 데이터를 변경해도 디스크에 쓰여지는 것은 요청을 할 때의 데이터이다. 

### 13.4.3. 캐싱(Caching)
캐시는 데이터의 복사본을 저장하는 빠른 메모리 영역이다. 
버퍼는 그 데이터를 가지고 있는 유일한 장소인 반면, 캐시는 다른 곳에 이미 저장되어 있는 데이터의 복사본을 빠른 저장 장소에 추가로 저장하는 것이다. 

### 13.4.4. 스풀링 및 장치 예약(Spooling and Device Reservation)
Spool(Simultaneous Peripheral Operations On-Line)은 인터리브(interleave)하게 동작할 수 없는 프린터 같은 장치를 위해 출력 데이터를 보관하는 버퍼이다. 

프린터는 한 번에 하나의 작업만을 수행하는데, 많은 응용 프로그램이 동시에 출력 데이터를 프린터로 전송할 수도 있다. 
운영체제는 각 출력이 섞이지 않도록, 출력을 대응되는 디스크 파일에 저장한다. 
그리고 응용 프로그램들이 출력 데이터를 만드는 것을 끝내면, 스풀링 시스템은 하나씩 프린터에 내보낸다. 

운영체제는 또한, 한 프로세스에게 특정 장치의 독점적으로 사용하게 하고, 다른 프로세스들은 장치를 기다리게 할 수도 있다. 

### 13.4.5. 오류 처리
입출력 요청은 일시적(네트워크에 너무 많은 요청)이나 영구적(디스크 고장)으로 많은 이유에서 실패할 수 있다. 
일반적으로 입출력 시스템 호출은 성공/실패를 나타내는 정보를 반환한다. 

UNIX 시스템은 오류의 종류까지 구분해서 반환하기도 한다. 
그리고 몇몇 하드웨어는 더 자세한 오류 정보를 제공한다. 

### 13.4.6. 입출력 보호
사용자가 불법적인 입출력을 못하게 하기 위해, 모든 입출력 명령을 특권 명령(priviledged instruction)으로 정의된다. 
따라서 사용자는 운영체제가 입출력을 대신 수행하도록 시스템 호출을 사용해야한다. 

<figure style="width: 500px" class="align-center">
 	<img src="{{ '/assets/img/2021-02-14-operating_system_13/7.png' }}" alt=""> 
</figure> 

Memory-mapped 와 I/O port 메모리 영역도 메모리 보호 시스템에 의해 보호되어야 한다. 
하지만 모든 사용자의 접근을 거부해서는 안된다. 

예를 들어, 그래픽 게임은 그래픽 성능을 높이기 위해 memory-mapped 그래픽 제어기 메모리를 직접 접근할 필요가 있다. 
이 경우 운영체제는, 그래픽 메모리가 한번에 한 프로세스에게 할당되도록 잠금 기법을 제공해야 한다. 

### 13.4.7. 커널 자료구조
운영체제는 입출력 구성 요소에 대한 상태 정보를 유지해야 한다. 
운영체제는 열린 파일 테이블 구조와 같은 다양한 구조를 유지한다. 
이러한 자료구조들은 객체지향적이며, 공통의 인터페이스를 사용하여 다양한 종류의 입출력 장치에 유연하게 접근할 수 있게 해준다. 

<figure style="width: 650px" class="align-center">
 	<img src="{{ '/assets/img/2021-02-14-operating_system_13/8.png' }}" alt=""> 
</figure> 

### 13.4.8. 커널 입출력 서브시스템 요약
* 파일 및 장치의 이름 관리, 접근 제어
* 작업 제어, 입출력 스케줄링
* 파일 시스템을 위한 공간 할당
* 장치 할당, 버퍼링, 캐싱 및 스풀링 
* 장치 상태 모니터링, 오류 처리 및 고장 복구
* 장치 드라이버 구성 및 초기화

입출력 서브시스템의 상위 계층은 장치 드라이버가 제공하는 공통 인터페이스를 통해 장치에 접근한다. 

## 13.5. 입출력 요구를 하드웨어 연산으로 변환(Transforming I/O Requests to Hardware Operations)
응용 프로그램이 파일명으로 데이터를 참조하면 운영체제는 디스크 내에서 이 파일이 위치한 곳을 파일 시스템 디렉터리를 통해 알아낸다. 

DOS에서 콜론 앞에 오는 파일명의 첫 번째 부분은 특정 장치를 알려준다. 
콜론으로 인해 장치 이름이 파일 이름과 구분된다(C:, LPT:, ...). 

UNIX는 장치 이름을 보통의 파일 이름처럼 표시한다. 
UNIX는 경로 이름의 접두어를 특정 장치 이름과 연관시키는 마운트 테이블을 갖고 있다. 
마운트 테이블의 항목이 장치 이름을 제공한다. 

UNIX가 이름을 파일 시스템 디렉터리 구조에서 찾으면, inode 번호 대신 <major, minor> 장치 번호를 얻게 된다. 
major 장치 번호는 입출력을 처리하기 이해 호출할 장치 드라이버를 나타낸다. 
minor 장치 번호는 장치 드라이버에게 전달디고, 해당 장치 테이블에 대한 인덱스로 사용된다. 
장치 테이블의 항목이 장치 제어기의 포트 주소나 memory-mapped 주소를 제공한다. 

보통 운영체제들은 입출력 요청과 장치 제어기 사이에 여러 단계의 lookup table을 두어 유연성을 제공한다. 

---

봉쇄형 읽기 요청을 처리하는 흐름은 다음과 같다. 
1. 앞서 열린 파일의 file descriptor에게 봉쇄형 읽기 시스템 호출을 요청
2. 데이터가 버퍼 캐시에 있으면 반환 및 입출력 완료
3. 프로세스가 run queue에서 wait queue로 이동, 입출력 서브시스템이 장치 드라이버에게 요청을 보냄
4. 장치 드라이버가 데이터를 받기 위해 커널 버퍼를 할당받고, 장치 제어기의 장치-제어 레지스터에 명령을 보냄
5. 장치 제어기가 장치를 데이터 전송을 하도록 작동시킴
6. DMA 제어기가 커널 메모리에 데이터를 전송하고 인터럽트를 생성함
7. 인터럽트 벡터 테이블을 통해 적절한 인터럽트 핸들러가 인터럽트를 받고, 장치 드라이버에게 신호를 보냄
8. 장치 드라이버가 어떤 입출력이 완료되었는지 확인하고, 입출력 서브시스템에게 요청이 완료되었음을 알림
9. 커널이 요청한 프로세스에게 데이터를 전송하고, 프로세스를 wait queue에서 ready queue로 옮김
10. ready queue로 보내진 프로세스의 봉쇄가 풀리고, 스케줄러가 CPU에 할당할 수 있음

<figure style="width: 800px" class="align-center">
 	<img src="{{ '/assets/img/2021-02-14-operating_system_13/9.png' }}" alt=""> 
</figure> 

## 13.6. STREAMS
스트림은 장치 드라이버와 사용자 프로세스 사이의 양방향 연결을 말한다. 
스트림은 사용자 프로세스와 상호 연동하는 스트림 헤드와 장치를 제어하는 드라이버 엔드, 그 둘 사이에 존재하는 0개 이상의 스트림 모듈로 구성된다. 
각 구성요소들은 읽기와 쓰기를 위한 한 쌍의 큐를 가지고 있다. 
큐 사이의 데이터 전송은 message passing이 사용된다. 

<figure style="width: 530px" class="align-center">
 	<img src="{{ '/assets/img/2021-02-14-operating_system_13/10.png' }}" alt=""> 
</figure> 

큐는 흐름 제어(flow control)를 지원할 수 있다. 
흐름 제어가 없을 경우, 큐는 메세지를 받자마자 인접 모듈의 큐로 보낸다. 
흐름 제어를 사용하는 경우, 큐에서 메세지를 버퍼링하고, 버퍼 용량이 없을 때는 메세지를 받아들이지 않는다. 

스트림 입출력은 사용자 프로세스가 스트림 헤드와 통신할 때를 제외하고 비동기이다. 
스트림에 쓰기를 할 때, 큐에 공간이 있을 때까지 봉쇄되고, 읽을 때는 데이터가 이용 가능할 때 까지 봉쇄된다. 

드라이버 엔드는 네트워크로부터 프레임이 읽기 준비가 되었을 때 촉발되는 것과 같은 인터럽트에 반드시 응답해야 한다. 
그러나 장치의 버퍼가 가득 찼다면 장치는 일반적으로 수신되는 메세지를 버린다. 

스트림을 사용함으로써 얻는 이점은 장치 드라이버와 네트워크 프로토콜을 작성할 때 모듈식이며 점진적인 접근을 위한 프레임워크를 제공한다는 것이다. 
모듈은 다른 스트림, 다른 장치에 사용될 수 있다. 

예를 들어, 네트워크 모듈은 이더넷과 802.11 무선 네트워크 카드에 사용될 수 있다. 
또한, 통신할 때 메세지 경계와 모듈 간에 제어 정보를 지원한다. 

## 13.7. 성능
입출력 시스템은 성능에 매우 중요한 요소이다. 
이는 시스템의 다른 요소에 부담(인터럽트 핸들링, 문맥 교환, 메모리 접근, 버스 경쟁 등)을 줄 수 있다. 

<figure style="width: 720px" class="align-center">
 	<img src="{{ '/assets/img/2021-02-14-operating_system_13/11.png' }}" alt=""> 
</figure> 

어떤 시스템들은 front-end-processor를 사용하여 CPU로부터 인터럽트 부담을 덜고 있다. 
예를 들어, terminal concentrator는 수백 개의 원격 터미널에서 들어오는 정보를 multiplex 할 수 있다. 
대형 시스템에서는 특수 목적 CPU인 입출력 채널(I/O channel)을 쓸 수도 있다. 

입출력의 효율을 높이기 위해 여러 가지 원칙들을 적용할 수 있다. 
* 문맥 교환의 빈도를 줄인다. 
* 장치와 응용 프로그램에서 데이터를 주고 받을 때, 데이터가 복사되는 횟수를 줄인다. 
* 인터럽트 빈도를 줄인다. 
* DMA나 입출력 채널을 사용한다. 
* 기본 처리 연산을 하드웨어에 구현하여 작업이 CPU와 장치 제어기에서 병렬적으로 진행되게 한다. 
* CPU, 메모리, 버스, 입출력 등에 대한 부하가 균일하게 되도록 한다.

새로운 입출력 알고리즘은, 먼저 응용 프로그램 수준에서 구현되고 점차 커널, 하드웨어 수준으로 점진적으로 발전한다. 
저수준 구현은 빠르고 효율적이고, 고수준 구현은 수정이 쉽고 융통성이 많다.

