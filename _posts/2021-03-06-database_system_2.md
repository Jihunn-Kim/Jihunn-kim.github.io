---
title: "데이터 베이스 요약 - 2. 관계 데이터 모델과 제약조건"
last_modified_at: 2021-05-13
show_date: true
classes: wide
excerpt: ""
categories:
  - database
---

## 2.1. 관계 데이터 모델의 개념
관계 데이터 모델은 동일한 구조(릴레이션)의 관점에서 모든 데이터를 논리적으로 구성함. 
논리적으로 연관된 데이터를 연결하기 위해서 링크나 포인터를 사용하지 않음. 

그리고 선언적인 질의어를 통한 데이터 접근을 제공함. 
사용자는 원하는 데이터(what)만 명시하고, 어떻게(how) 데이터를 찾을 것인가는 명시할 필요가 없음. 
응용 프로그램들은 데이터베이스 내의 레코드들의 어떠한 순서와도 무관하게 작성될 수 있음. 

---

기본적인 용어는 다음과 같다. 

(1) 릴레이션(relation): 2차원 테이블. 

(2) 레코드(record): 릴레이션의 각 행, 투플(tuple)이라고도 부름. 

(3) 애트리뷰트(attribute): 릴레이션에서 이름을 가진 하나의 열. 

(4) 도메인(domain): 한 애트리뷰트에 나타날 수 있는 값들의 집합. 
도메인의 값들은 원자값, 즉, 여러 값은 허용되지 않음. 
프로그래밍 언어의 데이터 타입과 유사. 

(5) 차수(degree): 한 릴레이션에 있는 애트리뷰트들의 수. 

(6) 카디날리티(cardinality): 릴레이션의 투플 수. 

(7) 널 값(null value): '알려지지 않음' 또는 '적용할 수 없음' 을 나타내기 위해 사용. 
널 값은 숫자의 0, 공백 문자/문자열과 다름. 

<figure style="width: 500px" class="align-center">
 	<img src="{{ '/assets/img/2021-03-06-database_system_2/1.png' }}" alt=""> 
</figure> 

(8) 릴레이션 스키마(relation schema): 릴레이션의 이름과 릴레이션의 애트리뷰트들의 집합. 
기본 키 애트리뷰트에는 밑줄 표시 
> 릴레이션이름 (<u>애트리뷰트1</u>, 애트리뷰트2, ... 애트리뷰트N) 

(9) 릴레이션 인스턴스(relation instance): 릴레이션에 어느 시점에 있는 투플들의 집합. 

(10) 관계 데이터베이스(relational database) 스키마: 하나 이상의 릴레이션 스키마들로 이루어짐. 

(11) 관계 데이터베이스 인스턴스: 릴레이션 인스턴스들의 모임으로 구성됨. 

<figure style="width: 500px" class="align-center">
 	<img src="{{ '/assets/img/2021-03-06-database_system_2/2.png' }}" alt=""> 
</figure> 

## 2.2. 릴레이션의 특성
(1) 한 애트리뷰트 내의 값들은 모두 같은 타입. 

(2) 각 애트리뷰트의 이름은 한 릴레이션 내에서만 고유. 

(3) 애트리뷰트들의 순서는 중요하지 않음. 

(4) 투플들의 순서는 중요하지 않음. 

(5) 동일한 투플이 두 개 이상 존재하지 않음. 구별을 위한 키가 존재함. 

(6) 한 투플의 각 애트리뷰트는 원자값을 가짐. 

<figure style="width: 400px" class="align-center">
 	<img src="{{ '/assets/img/2021-03-06-database_system_2/3.png' }}" alt=""> 
</figure> 

## 2.3. 릴레이션의 키
키는 각 투플을 고유하게 식별할 수 있는 하나 이상의 애트리뷰트들의 모임이다. 

(1) 수퍼 키(super key): 한 릴레이션 내의 특정 투플을 고유하게 식별하는 하나 이상의 애트리뷰트들. 
투플들을 고유하게 식별하는데 꼭 필요하지 않은 애트리뷰트들을 포함할 수 있음. 

(2) 후보 키(candidate key): 각 투플을 고유하게 식별하는 최소한의 애트리뷰트들의 모임. 
모든 릴레이션에는 최소한 한 개 이상의 후보 키가 있음. 
후보 키도 두 개 이상의 애트리뷰트로 이루어질 수 있으며, 이런 경우에 복합 키(compositekey)라고 부름. 

(3) 기본 키(primary key): 한 릴레이션에 후보 키가 두 개 이상 있으면 이들 중에서 하나를 기본 키로 선정함. 
자연스러운 기본 키를 찾을 수 없는 경우에는 레코드 번호와 같이 인위적인 키 애트리뷰트를 릴레이션에 추가할 수 있음. 

(4) 대체 키(alternate key): 기본 키가 아닌 후보 키.

(5) 외래 키(foreign key): 어떤 릴레이션의 기본 키를 참조하는 애트리뷰트. 
관계 데이터베이스에서 릴레이션들 간의 관계를 나타내기 위해서 사용됨. 
외래 키 애트리뷰트는 참조되는 릴레이션의 기본 키와 동일한 도메인을 가져야함. 

다른 릴레이션의 기본 키를 참조하거나, 자체 릴레이션의 기본 키를 참조할 수 있음. 
자체 릴레이션의 기본 키의 구성요소가 되거나 되지 않을수 있음. 

<figure style="width: 440px" class="align-center">
 	<img src="{{ '/assets/img/2021-03-06-database_system_2/4.png' }}" alt=""> 
</figure> 

## 2.4. 무결성 제약조건
데이터 무결성(dataintegrity)은 데이터의 정확성 또는 유효성을 의미. 
일관된 데이터베이스 상태를 정의하는 규칙들을 정의함. 
데이터베이스가 갱신될 때 DBMS가 자동적으로 일관성 조건을 검사함. 

---

(1) 도메인 제약조건(domain constraint): 각 애트리뷰트 값이 반드시 원자 값이어야 함. 
애트리뷰트 값의 타입 및 디폴트 값, 가능한 값들의 범위 등을 지정할 수 있음. 

```mysql
CREATE TABLE Persons (
	ID int NOT NULL, 
	LastName varchar(255) NOT NULL, 
	FirstName varchar(255), 
	Age int DEFAULT -1,	// int 유형, 디폴트 값 -1
	CHECK (Age>=18)		// 값 범위 제한
);
```

---

(2) 키 제약조건(key constraint): 키 애트리뷰트에 중복된 값이 존재해서는 안됨. 
```mysql
CREATE TABLE Persons (
	ID int NOT NULL, 
	LastName varchar(255) NOT NULL, 
	FirstName varchar(255), 
	Age int, 
	UNIQUE (ID) // 고유함
);
```

---

(3) 기본 키와 엔티티(5.2절 내용) 무결성 제약조건(entity integrity constraint): 기본 키가 투플들을 식별하는데 사용되기에, 기본 키를 구성하는 어떤 애트리뷰트도 널 값을 가질 수 없다. 
대체 키에는 적용되지 않음. 

---

(4) 외래 키와 참조 무결성 제약조건(referential integrity constraint): 참조 무결성 제약조건은 두 릴레이션의 연관된 투플들 사이의 일관성을 유지하는데 사용됨. 
아래 그림에서 릴레이션 EMPLOYEE의 외래 키가 릴레이션 DEPARTMENT의 기본 키를 참조할 때 참조 무결성 제약조건은 아래 두 조건 중 하나가 성립되면 만족됨. 
1. 외래 키의 값은 EMPLOYEE의 어떤 투플의 기본 키 값과 같다. 
2. 널 값을 가진다. 단, 외래 키가 자체 릴레이션의 기본 키를 구성하고 있지 않음. 
	- 릴레이션의 기본 키의 일부이면 널 값을 가질 수 없음.

<figure style="width: 450px" class="align-center">
 	<img src="{{ '/assets/img/2021-03-06-database_system_2/5.png' }}" alt=""> 
</figure> 

---

데이터베이스에 대한 갱신 연산은 삽입, 삭제, 수정 연산으로 구분함. 
DBMS는 갱신 연산에 대하여 데이터베이스가 무결성 제약조건들을 만족하도록 필요한 조치를 취함. 

위의 그림에서 DEPARTMENT를 참조된 릴레이션, EMPLOYEE를 참조하는 릴레이션으로 부르기로 하자. 

(1) 삽입: 참조되는 릴레이션에 새로운 투플이 삽입되면 참조 무결성 제약조건은 위배되지 않음. 
하지만, 참조하는 릴레이션에 새로운 투플을 삽입할 때는 도메인, 키, 엔티티 무결성, 참조 무결성 제약조건을 위배할 수 있음. 
> EMPLOYEE릴레이션에 (4325, 오혜원, 6)이라는 투플을 삽입하면 참조 무결성 제약조건을 위배하게 됨  
> 제약조건을 위배하는 삽입 연산은 DBMS가 거절함으로써 무결성 유지. 

(2) 삭제: 참조하는 릴레이션에서 투플이 삭제되면 모든 제약조건을 위배하지 않음. 
하지만, 참조되는 릴레이션에서 투플이 삭제되면 참조 무결성 제약조건을 위배하는 경우가 생길수도 있음. 
> DEPARTMENT릴레이션에서 네번째 투플인(4, 홍보, 8)을 삭제하더라도 참조 무결성 제약조건을 위배하지 않음  
> DEPARTMENT릴레이션에서 세번째 투플인(3, 개발, 9)를 삭제하면 참조 무결성 제약조건을 위배하게 됨. 

(3) 수정: DBMS는 수정하는 애트리뷰트가 기본 키인지 외래 키인지 검사함. 
수정하려는 애트리뷰트가 기본 키도 아니고 외래 키도 아니면, 수정 연산이 참조 무결성 제약조건을 위배하지 않음. 
기본 키나 외래 키를 수정하는 것은 하나의 투플을 삭제하고 새로운 투플을 그 자리에 삽입하는 것과 유사.

---

참조 무결성 제약조건을 만족시키기 위해서 DBMS가 제공하는 옵션들은 다음과 같다. 

(1) 제한(restricted): 위배를 야기한 연산을 단순히 거절. 
> DEPARTMENT릴레이션에서 (3, 개발, 9)를 삭제하면 참조 무결성 제약조건을 위배하게 되므로 삭제 연산을 거절 

(2) 연쇄(cascade): 참조되는 릴레이션에서 투플을 삭제하고, 참조하는 릴레이션에서 이 투플을 참조하는 투플들도 함께 삭제. 
> DEPARTMENT릴레이션에서 (3, 개발, 9)를 삭제하면 EMPLOYEE릴레이션에서 부서번호 3을 참조하는 두 번째 투플과 다섯 번째 투플도 함께 삭제 

(3) 널값(nullify): 참조되는 릴레이션에서 투플을 삭제하고, 참조하는 릴레이션에서 이 투플을 참조하는 투플들의 외래 키에 널 값을 삽입. 
> DEPARTMENT릴레이션에서 (3, 개발, 9)를 삭제하면 EMPLOYEE릴레이션에서 부서번호 3을 참조하는 두 번째 투플과 다섯 번째 투플의 부서번호에 널 값을 삽입 

(4) 디폴트 값: 널 값을 넣는 대신에 디폴트 값을 넣는다는 것을 제외하고는 (3)과 비슷함. 

