---
title: "운영체제 요약 - 2. 시스템 구조"
last_modified_at: 2021-01-24
excerpt: ""
categories:
  - operating_system
---

## 1. 운영체제 서비스
운영체제는 아래와 같이 프로그램 실행 환경을 제공한다. 
* 사용자 인터페이스
* 프로그램 수행
* 입출력 연산
* 파일 시스템 조작
* 통신
* 오류 탐지
* 자원 할당
* 자원 기록 관리
* 보호와 보완

---

## 2. 사용자 운영체제 인터페이스

### 2.1. 명령어 해석기
명령어 해석기는 셸(shell)이라고도 불린다. 이는 문자열 명령으로 운영체제와 소통한다. 
사용자가 명령을 입력하면, 해석기가 명령을 수행하기 위한 한 부분으로 분기하고 적절한 매개변수를 사용하여 시스템 호출을 한다. 
자주 사용되는 명령을 셸 스크립트(shell scripts) 파일로 만들어 사용할 수 있다. 

---

### 2.2. 그래피컬 사용자 인터페이스
마우스, 터치 등을 사용하여 프로그램, 파일 등을 나타내는 화면상의 이미지(아이콘)을 눌러 프로그램을 호출할 수 있다. 

---

## 3. 시스템 호출
운영체제의 기능을 사용하기 위해 직업 시스템 호출을 활용하는 대신, 대부분 응용 프로그래밍 인터페이스(Application Programming Interface, API)를 사용한다. 
API는 각 함수에 전달되어야 할 매개변수들과 반한 값을 포함하여 프로그래머가 사용 가능한 함수의 집합이다. 
API를 사용함으로써 프로그래머는 같은 API를 지원하는 시스템에서는 컴파일 되고 실행된다는 것을 기대할 수 있다. 
또한 실제 시스템 호출은 API보다 자세한 명세가 필요하기에 사용하기 더 어렵다. 
따라서 시스템 호출 인터페이스가 API 호출에 맞는 시스템 호출을 대신 부른다. 

---

## 4. 시스템 호출의 유형
시스템 호출은 프로세스 제어, 파일 조작, 장치 조작, 정보 유지 보수, 통신과 보호의 범주로 묶을 수 있다. 

### 4.1. 프로세스 제어
* 프로그램은 정상적 또는 비정상적으로 종료된다. 비정상적으로 종료되었을 경우, 디스크에 오류 메세지를 저장한다. 
* 프로그램을 메모리에 올리고 실행한다. 
* 프로그램이 다른 프로그램을 생성(호출)할 수 있다.
* 실행 제어를 위해 프로세서의 속성(우선 순위, 실행 시간 등)을 가져오고 재설정할 수 있다.
* 다른 프로세서가, 끝나기를 기다리거나 끝났다고 알릴 수 있다. 
* 공유 데이터의 일관성 확보를 위해 공유 데이터를 잠글 수 있다. 

---

### 4.2. 파일 관리
* 파일 생성, 삭제, 읽기, 쓰기, 속성 설정이 있다.
* 파일을 조직하기 위한 디렉토리에도 같은 기능이 있다.

---

### 4.3. 장치 관리
* 장치 요청, 해제, 읽기, 쓰기가 가능하다.

---

### 4.4. 정보의 유지
* 현재 시간, 자유 메모리 공간, 프로그램이 수행한 시간을 알 수 있다.

---

### 4.5. 통신
* 프로세스끼리 정보를 교환하는 방법에는 메세지 전달 모델과 공유 메모리 모델이 있다.
* 메세지 전달에서 사용되는 식별을 위해 컴퓨터 호스트 이름, 프로세스 이름을 알 수 있다.
* 공유 메모리에서는 메모리 영역에 대한 접근 등의 기능이 있다.

---

### 4.6. 보호
* 파일과 디스크와 같은 자원에 허가권한을 설정할 수 있다.
* 사용자에 권한을 부여하여 지정된 자원에 접근을 조절할 수 있다.

---

## 5. 시스템 프로그램
논리적인 컴퓨터 계층 구조는, 최하위 수준부터 하드웨어, 운영체제, 시스템 프로그램, 응용 프로그램이다. 
시스템 프로그램은 프로그램 개발과 실행을 위해 보다 편리한 환경을 제공한다. 
아래와 같은 유형들이 있다. 
* 파일 관리, 변경
* 프로그램, 장치 상태 정보
* 컴파일러, 디버거 등 프로그래밍 언어 지원
* 로더나 링키지 에디터를 통한 프로그램 적재 및 수행
* 통신
* 시스템이 정지할 때 까지 계속해서 실행되는 백그라운드 서비스 

---

## 6. 운영체제 구조
운영체제와 같이 크고 복잡한 시스템이 적절하게 동작하고 쉽게 변경될 수 있으려면, 한 개의 시스템보다는 작은 구성 요소(모듈)로 구성되는 것이 좋다. 

### 6.1. 간단한 구조
기능 계층이 잘 분리되지 않은 MS-DOS, 최초 UNIX 운영체제가 있다. 
MS-DOS의 경우 대상으로 하는 Intel 8088이 이중 모드와 하드웨어 보호 기능을 제공하지 않아 하드웨어 기능에 의해 보호 기능에 제한받았다. 
예를 들어, 응용 프로그램이 디스플레이와 디스크 드라이브에 직접 쓰기가 가능하여 오류가 생기면 시스템 전체가 고장날 수 있다. 

최초 UNIX 운영체제는 하나의 계층(모놀리식)으로 커널이 구성되어 구현 및 유지 보수가 어려웠다. 
하지만, 시스템 호출 인터페이스나 커널 안에서 통신하는 경우에는 오버헤드가 거의 없어 성능 측면에서는 이점을 가진다. 

---

### 6.2. 계층적 접근
시스템은 다양한 방식으로 모듈화 될 수 있따. 한가지 방식은 계층적 접근 방식이다. 
계층적 접근 방식의 주된 장점은 구현과 디버깅의 간단함에 있다. 
각 층은 자신보다 하위 층들의 서비스들만 사용하여 구현한다. 
따라서 하위 층부터 점진적으로 개발한다면, 하위 층은 이미 디버그된 상태란 것을 알 수 있다. 
단점은 계층을 적절히 정의하는 것이 어렵고, 응용 프로그램이 하드웨어 접근까지 여러번의 호출 과정을 거쳐야 하는 오버헤드가 있다는 점이다. 

---

### 6.3. 마이크로 커널
이 방법은 중요치 않은 구성 요소를 커널로부터 제거하고, 그것들을 시스템 및 사용자 수준 프로그램으로 구현하여 운영체제를 구성하는 방법이다. 
마이크로 커널 구조에서 사용자 수준 프로그램들은 커널을 통하여 서로 접근한다. 
파일시스템이 사용자 수준으로 구현되었다면, 파일 접근시 매번 커널을 통과해야 한다. 
마이크로 커널은 가중된 시스템 기능 오버헤드(본문: increasedsystem-function overhead) 때문에 성능이 나빠진다. 
Windows NT는 계층들을 사용자 공간으로부터 커널 공간으로 옮기고 그것들을 통합하여 성능을 개선하였다. (너무 많은 커널 서비스들이 사용자 수준으로 올라간 것을 해결한 것이라 이해하였다) 

---

### 6.4. 모듈
커널은 핵심적인 구성요소를 가지고 있고, 부팅 또는 실행 중에 부가적인 서비스(모듈)들을 링크한다. 
모듈이 다른 모듈을 호출할 수 있어 계층 구조보다 유연하며, 모듈간 통신에 마이크로 커널처럼 커널을 통할 필요가 없다. 

---

### 6.5. 혼용 시스템
대부분 앞선 구조들을 결합하여 사용한다. 
Linux, Windows, Mac OS, iOS, Android 등에서 혼용 구조를 사용하고 있다. 

---

## 7. 운영체제 디버깅
디버깅은 하드웨어와 소프트웨어에서 시스템의 오류를 발견하고 수정하는 행위이다. 
처리 중에 발생하는 병목 현상을 제거하여 성능을 향상시키는 성능 조정도 디버깅에 포함된다. 

### 7.1. 장애 분석
대부분의 운영체제는 문제가 발생하면 사용하던 메모리의 내용을 파일로 저장한다. 
이는 나중에 디버거를 통해 분석될 수 있다. 

### 7.2. 성능 조정
병목 지점을 발견하기 위해서 시스템 동작을 측정하고 표시할 수 있는 방법이 있어야 한다. 
많은 운영체제는 시스템 동작을 기록한다. 시간과 중요 매개변수와 함께 로그 파일에 기록되어 추후에 분석될 수 있다. 

### 7.3. DTrace
DTrace는 커널과 사용자 응용 프로그램 문제의 정보를 얻을 수 있는, 유닉스 계열에서 쓸 수 있는 동적 기록 프레임워크이다. 
검사점을 사용하여 메모리의 양, CPU 시간 등 커널과 프로그램의 로그 정보를 얻어낼 수 있다. 

## 8. 시스템 부트
ROM에는 부트스트랩 로더가 있다. 이는 기계의 상태 등을 진단하고 디스크에서 운영체제가 저장된 부트 블록을 찾는다. 
부트 블록에서 운영체제가 메모리로 적재되고 실행을 시작한다. 
