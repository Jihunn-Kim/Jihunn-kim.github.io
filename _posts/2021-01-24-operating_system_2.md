---
title: "운영체제 요약 - 2. 시스템 구조"
last_modified_at: 2021-04-06
show_date: true
classes: wide
excerpt: ""
categories:
  - operating_system
---

## 2.1. 운영체제 서비스(Operating-System Services)
운영체제는 프로그램 실행 환경을 제공한다. 
* 사용자 인터페이스
* 프로그램 수행
* 입출력 연산
* 파일 시스템 조작
* 통신
* 오류 탐지
* 자원 할당
* 자원 기록 관리
* 보호와 보안

<figure style="width: 500px" class="align-center">
 	<img src="{{ '/assets/img/2021-01-24-operating_system_2/1.png' }}" alt=""> 
</figure> 

## 2.2. 사용자 운영체제 인터페이스(User Operating-System Interface)

### 2.2.1. 명령어 해석기(Command-Interpreter)
명령어 해석기는 셸(shell)이라고도 불린다. 
이는 문자열 명령으로 운영체제와 소통한다. 

사용자가 명령을 입력하면, 해석기가 명령을 수행하기 위한 한 부분으로 분기하고 적절한 매개변수를 사용하여 시스템 호출을 한다. 
자주 사용되는 명령을 셸 스크립트(shell scripts) 파일로 만들어 사용할 수 있다. 

### 2.2.2. 그래피컬 사용자 인터페이스(Graphical User Interface)
마우스, 터치 등을 사용하여 프로그램, 파일 등을 나타내는 화면상의 이미지(아이콘)을 눌러 프로그램을 호출할 수 있다. 

## 2.3. 시스템 호출(System Calls)
운영체제의 기능을 사용하기 위해 직접 시스템 호출을 활용하는 대신, 대부분 응용 프로그래밍 인터페이스(Application Programming Interface, API)를 사용한다. 
API는 각 함수에 전달되어야 할 매개변수들과 반한 값을 포함하며, 프로그래머가 사용 가능한 함수의 집합이다. 

API를 사용함으로써 얻는 이점은 다음과 같다. 
- 프로그래머는 같은 API를 지원하는 시스템에서는 코드가 컴파일 되고 실행되리라 기대할 수 있음 
- 자세한 명세가 필요한 실제 시스템 호출보다 API가 사용하기 더 쉬움 
따라서 API를 사용하며, 시스템 호출 인터페이스가 API 호출에 맞는 시스템 호출을 한다. 

<figure style="width: 600px" class="align-center">
 	<img src="{{ '/assets/img/2021-01-24-operating_system_2/2.png' }}" alt=""> 
</figure> 

## 2.4. 시스템 호출의 유형(Types of System Calls)
시스템 호출은 프로세스 제어, 파일 조작, 장치 조작, 정보 유지 보수, 통신과 보호의 범주로 묶을 수 있다. 

### 2.4.1. 프로세스 제어(Process Control)
* 프로그램은 정상적 또는 비정상적으로 종료된다. 비정상적으로 종료되었을 경우, 디스크에 오류 메세지를 저장한다.
* 프로그램을 메모리에 올리고 실행한다.
* 프로그램이 다른 프로그램을 생성(호출)할 수 있다.
* 실행 제어를 위해 프로세서의 속성(우선 순위, 실행 시간 등)을 가져오고 재설정할 수 있다.
* 다른 프로세서가, 끝나기를 기다리거나 끝났다고 알릴 수 있다.
* 공유 데이터의 일관성 확보를 위해 공유 데이터를 잠글 수 있다.

### 2.4.2. 파일 관리(File Management)
* 파일 생성, 삭제, 읽기, 쓰기, 속성 설정 등이 있다.
* 파일을 조직하기 위한 디렉토리에도 같은 기능이 있다.

### 2.4.3. 장치 관리(Device Management)
* 장치 요청, 해제, 읽기, 쓰기가 가능하다.

### 2.4.4. 정보의 유지(Information Management)
* 현재 시간, 자유 메모리 공간, 프로그램이 수행한 시간을 알 수 있다.

### 2.4.5. 통신(Communication)
* 프로세스끼리 정보를 교환하는 방법에는 메세지 전달 모델과 공유 메모리 모델이 있다.
* 메세지 전달에서 사용되는 식별을 위해 컴퓨터 호스트 이름, 프로세스 이름을 알 수 있다.
* 공유 메모리에서는 메모리 영역에 대한 접근 등의 기능이 있다.

### 2.4.6. 보호(Protection)
* 파일과 디스크와 같은 자원에 허가권한을 설정할 수 있다.
* 사용자에 권한을 부여하여 지정된 자원에 접근을 조절할 수 있다.

## 2.5. 시스템 프로그램(System Programs)
논리적인 컴퓨터 계층 구조는, 최하위 수준부터 하드웨어, 운영체제, 시스템 프로그램, 응용 프로그램 순이다. 

시스템 프로그램은 프로그램 개발과 실행을 위해 편리한 환경을 제공한다. 
* 파일 관리, 변경
* 프로그램, 장치 상태 정보
* 컴파일러, 디버거 등 프로그래밍 언어 지원
* 로더나 링커를 통한 프로그램 적재 및 수행
* 통신
* 시스템이 정지할 때 까지 계속해서 실행되는 백그라운드 서비스 

## 2.6. 운영체제 구조(Operating-System Structures)
운영체제와 같이 크고 복잡한 시스템이 적절하게 동작하고 쉽게 변경될 수 있으려면, 한 개의 시스템보다는 작은 구성 요소(모듈)로 구성되는 것이 좋다. 

### 2.6.1. 간단한 구조(Simple Structure)
MS-DOS의 경우 Intel 8088이 이중 모드와 하드웨어 보호 기능을 제공하지 않아 하드웨어 기능에 제한적이었다. 
예를 들어, 응용 프로그램이 디스플레이와 디스크 드라이브에 직접 쓰기가 가능하며, 오류가 생기면 시스템 전체가 고장날 수 있다. 

최초의 UNIX 운영체제는 하나의 계층(모놀리식; monolithic)으로 커널이 구성되어 구현 및 유지 보수가 어려웠다. 
하지만, 시스템 호출 인터페이스나 커널 안에서 통신하는 경우에는 오버헤드가 거의 없어 성능 측면에서는 이점을 가진다. 

### 2.6.2. 계층적 접근(Layerd Approach)
시스템은 다양한 방식으로 모듈화 될 수 있다. 
한가지 방식은 계층적 접근 방식이다. 

계층적 접근 방식의 주된 장점은 구현과 디버깅의 간단함에 있다. 
각 층은 자신보다 하위 층들의 서비스들만 사용하여 구현한다. 

따라서 하위 층부터 점진적으로 개발한다면, 하위 층은 이미 디버그된 상태란 것을 알 수 있다. 
단점은 계층을 적절히 정의하는 것이 어렵고, 응용 프로그램이 하드웨어 접근까지 여러번의 호출 과정을 거쳐야 하는 오버헤드가 있다는 점이다. 

### 2.6.3. 마이크로 커널(Microkernels)
중요치 않은 구성 요소를 커널로부터 제거하고, 그것들을 시스템 및 사용자 수준 프로그램으로 구현하여 운영체제를 구성할 수 있다. 
마이크로 커널 구조에서 사용자 수준 프로그램들은 커널을 통하여 서로 접근한다. 

파일시스템이 사용자 수준으로 구현되었다면, 파일 접근시 매번 커널을 통과해야 한다. 
따라서, 마이크로 커널은 시스템 기능 오버헤드 때문에 성능이 나빠진다. 

### 2.6.4. 모듈(Modules)
커널은 핵심적인 구성요소를 가지고 있고, 부팅 또는 실행 중에 부가적인 서비스(모듈)들을 링크한다. 
모듈이 다른 모듈을 호출할 수 있어 계층 구조보다 유연하며, 모듈간 통신에 마이크로 커널처럼 커널을 통할 필요가 없다. 

### 2.6.5. 혼용 시스템(Hybrid Systems)
대부분 앞선 구조들을 결합하여 사용한다. 
Linux, Windows, Mac OS, iOS, Android 등에서 혼용 구조를 사용하고 있다. 

## 2.7. 운영체제 디버깅(Operating-System Debugging)
디버깅은 하드웨어와 소프트웨어에서 시스템의 오류를 발견하고 수정하는 행위이다. 
처리 중에 발생하는 병목 현상을 제거하여 성능을 향상시키는 성능 조정도 디버깅에 포함된다. 

### 2.7.1. 장애 분석(Failure Analysis)
대부분의 운영체제는 문제가 발생하면 사용하던 메모리의 내용을 파일로 저장한다. 
이는 나중에 디버거를 통해 분석될 수 있다. 

### 2.7.2. 성능 조정(Performance Tuning)
병목 지점을 발견하기 위해서 시스템 동작을 측정하고 표시할 수 있는 방법이 있어야 한다. 
많은 운영체제는 시스템 동작을 시간과 중요 매개변수와 함께 로그 파일에 기록하며, 이는 추후에 분석될 수 있다. 

### 7.3. DTrace
DTrace는 커널과 사용자 응용 프로그램 문제의 정보를 얻을 수 있는, 유닉스 계열에서 쓸 수 있는 동적 기록 프레임워크이다. 
검사점을 사용하여 메모리의 양, CPU 시간 등 커널과 프로그램의 로그 정보를 얻어낼 수 있다. 

## 2.8. 시스템 부트(System Boot)
컴퓨터가 전원을 켜거나 재부팅 등의 리셋 사건을 받으면, 명령 레지스터는 미리 지정된 메모리 위치를 가리키게 되고 그 곳에서부터 실행을 시작한다. 
그 위치에는 부트스트랩 로더가 있으며, 보통 ROM/EPROM에 저장되어 있다. 

이는 기계의 상태 등을 진단하고 디스크에서 운영체제가 저장된 부트 블록을 찾는다. 
부트 블록에서 운영체제가 메모리로 적재되고 실행을 시작한다. 

